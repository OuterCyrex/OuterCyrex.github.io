---
layout:       post
title:        "GoWeb开发的gin框架学习 part five"
author:       "OuterCyrex"
header-style: text
catalog:      true
tags:
    - Web
    - Golang
---

[TOC]



# 五.中间件和路由

##  一.中间件

### 1.引入

经过观察`GET`等方法的**源码**我们会发现：

```go
func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes {
	return group.handle(http.MethodGet, relativePath, handlers)
}
```

以`GET`为例，我们发现他可以接受一个**相对路径**和多个**`HandlerFunc`**。

如：

```go
package main

import (
	"github.com/gin-gonic/gin"
)

func main() {
	router := gin.Default()
	router.GET("/", func(c *gin.Context) {
		c.JSON(200, gin.H{"message": "1"})
	}, func(c *gin.Context) {
		c.JSON(200, gin.H{"message": "2"})
	})
	_ = router.Run(":8080")
}
```

该程序的**返回值**为：

```json
{"message": "1"}{"message": "2"}
```

由此我们可知，`GET`方法对于每一个**`HandlerFunc`**函数都会进行一次**响应**。因此，我们可以选取其中的一些函数作为**中间件**，来对**前端**传入的数据进行**检测**等操作。

注意，`GET`方法在处理多个`HandlerFunc`函数时依照**线性**的先后顺序，先进先输出。

------

一些概念的阐释：

#### a.视图

**视图 (view)**，通常负责处理**用户请求**并生成相应的**响应**。**图函数**或**视图类**接收**HTTP请求**（如`GET`、`POST`等），执行相应的业务逻辑（可能包括与数据库的交互），然后返回一个**HTTP响应**，这个响应通常是一个**`HTML`页面、`JSON`数据**或其他格式的数据。

#### b.中间件

**中间件 (Middleware)**是一个可以介入HTTP请求和响应处理过程的**程序**。在Web开发框架中，**中间件**通常用于处理**全局性**的任务，如**日志记录**、**身份验证**、**异常处理**等。

------



### 2.拦截

通过`abort`方法，我们可以对**响应**的进程进行**拦截**。

```go
func abort(c *gin.Context) {
	c.JSON(200, gin.H{"msg": "yes"})
	c.Abort()
}

func main() {
	router := gin.Default()
	router.GET("/", abort, func(c *gin.Context) {
		c.JSON(200, gin.H{"msg": "No"})
	})
	_ = router.Run(":8080")
}
```

这里我们定义了一个函数**`abort`**，他将返回一个内容为**`yes`**的`JSON`值，并通过**`c.Abort()`**对`GET`的进程进行**拦截**。

因此，其输出内容应为：

```json
{"msg": "yes"}
```

此处`GET`的进程在`abort`函数处被**拦截**，所以输出`"msg":"No`的函数未能**响应**。

且`abort`函数的**拦截**是在该函数彻底完成后才开始的。

即下述代码能够**正常输出**：

```go
router.GET("/", func(c *gin.Context) {
		c.JSON(200, gin.H{"msg": "yes"})
	}, func(c *gin.Context) {
		c.Abort() //此处abort但该函数仍会继续进行
		c.JSON(200, gin.H{"msg": "No"})
	})
//返回值为：
{"msg":"yes"}{"msg":"No"}
```



### 3.Next

通过`gin`框架提供的`Next`方法，我们可以轻松的将**请求中间件**和**响应中间件**进行划分。

首先定义一下**请求中间件**和**相应中间件**

------

#### a.请求中间件

**请求中间件（Request Middleware）**是在HTTP请求到达**视图函数**之前被调用的**中间件**。

#### b.响应中间件

**响应中间件（Response Middleware）**是在HTTP响应被返回给**客户端**之前被调用的**中间件**。

------

我们先定义两个中间件：

```go
func MiddleWare1(c *gin.Context) {
	fmt.Println("first In")
	c.Next()
	fmt.Println("first Out")
}

func MiddleWare2(c *gin.Context) {
	fmt.Println("second In")
	c.Next()
	fmt.Println("second Out")
}
```

然后运行`GET`请求：

```go
router.GET("/", MiddleWare1, func(c *gin.Context) {
		c.JSON(200, gin.H{"msg": "I am View Func"})
	}, MiddleWare2)
```

我们忽略返回的`JSON`值，终端给出的返回值为：

```go
first In
second In
second Out
first Out
```

我们会发现，`c.Next()`执行了某种类似**栈**的执行顺序。

但实际上`Gin`并没有使用显式的**栈结构**来管理**中间件**的执行，但整体是采取**先进后出**的原则。`Gin`通过维护一个**中间件列表**，并根据当前处理到的位置来决定是否**调用** `c.Next()` 来继续执行后续中间件。

`Abort`方法也受`Next`的**执行顺序**影响。

```go
router.GET("/", MiddleWare1, func(c *gin.Context) {
		c.JSON(200, gin.H{"msg": "I am View Func"})
		c.Abort()
    //在视图函数中插入Abort，则视图函数后的中间件无法被执行
	}, MiddleWare2)
```

上述代码的输出结果为：

```go
first In
first Out
```

------

注意，`next`只是决定了语句的**执行顺序**，而**中间件函数**本身是已经被执行了的。一旦`Abort`方法位于`next`之后，即使按照**执行顺序**，`Abort`函数应该被先执行，但他也无法拦截`next`之后的那些**响应中间件**。

```go
func MiddleWare2(c *gin.Context) {
	fmt.Println("second In")
	c.Next()
	c.Abort()
	fmt.Println("second Out")
}
```

此处`Abort`是在所有**中间件函数**和**视图函数**均已被执行之后才执行的，所以他无法拦截任何一个函数。

输出结果：

```go
first In
second In
second Out
first Out
```

------

